 #Linux/ext文件系统 #Linux/linux文件系统 #linux 

# Ext 文件系统结构表

![[Ext2文件系统结构. 1.svg]]
# 超级块（Super Block）

## 超级块的概念

超级块在ext系统中用来描述整个文件系统的整体信息，例如：*整个文件系统的块数*，*inode数*，*未使用的inode/block数量*，*每个块具体分配的大小*等等。
有关详细的字段定义和字节内容，可以参考官方wiki的定义

> [ext4 Wiki 网址](https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#The_Super_Block)

> 在ext4 文件系统中，由于**sparse_super**这个标志默认启用超级块（SuperBlock）和块组描述符表（GDT）并不是存在于所有的块组中的，只有在第一个块组（块组0），以及后续的3，5，7的n次幂的块组中储存。而除了块组0以外的其他块组仅用来备份和恢复文件系统。

---
# 块组描述符表（GDT）

## 块组描述符（GD）和块组描述符表（GD）

块组描述符（Group Describtors）是用于描述一个块组的相关信息的

```c
struct ext_group_desc
{
	
}
```

虽然每个块组都需要块组描述符来记录块组的信息和属性元数据，但是不是每个块组中都存放了块组描述符。ext文件系统的存储方式是：*将它们组成一个GDT，并将该GDT存放于某些块组中，存放GDT的块组和存放superblock和备份superblock的块相同*，也就是说它们是同时出现在某一个块组中的。读取时也总是读取Group0中的块组描述符表信息。

假如block大小为4KB的文件系统划分了143个块组，每个块组描述符32字节，那么GDT就需要143\*32=4576字节即两个block来存放。这两个GDT block中记录了所有块组的块组信息，且存放GDT的块组中的GDT都是完全相同的。

## 保留GDT（Reserved GDT）

保留GDT用于以后扩容文件系统使用，防止扩容后块组太多，使得块组描述符超出当前存储GDT的blocks。保留GDT和GDT总是同时出现，当然也就和superblock同时出现了。

---
# 块位图（Block Bitmap）和inode位图（Inode Bitmap）

ext文件系统使用位图来表示一个block或者inode是否被使用，每个bitmap占用一个block的大小
当block大小为4096字节时，一个位图内最多就可以记录 4096\*8 = 32768 个 block或inode的使用情况

---

# inode表（Inode Table）

ext文件系统中，一个inode的大小为128个字节或者256个字节，而，一个block的最小大小是1024字节，最大可以达到4096字节。为了节省空间和查找效率，ext将多个inode的内容整合在一起，形成inode表存放，这样，一个4096字节大小的block最多可以存储32个inode

---
# inode基础知识

每个文件都有一个inode，它存储了文件的基本信息，类似于文件大小，创建，修改，删除的时间，文件类型等。
> 识别ext文件系统的系统通过inode来找到对应的文件，而不是通过文件名

```c
struct ext_inode
{

}

```

## 硬链接和软连接
### 硬链接

虽然每个文件都有一个inode，但是存在一种可能：*多个文件的inode相同*，也就即inode号、元数据、block位置都相同，这是一种什么样的情况呢?能够想象这些inode相同的文件使用的都是同一条inode记录，所以代表的都是同一个文件，这些文件所在目录的data block中的inode指针目的地都是一样的，只不过各指针对应的文件名互不相同而已。这种inode相同的文件在Linux中被称为**硬链接**。

硬链接文件的inode都相同，每个文件都有一个"硬链接数"的属性，使用ls -l的第二列就是被硬链接数，它表示的就是该文件有几个硬链接。
### 软链接

软链接就是字符链接，链接文件默认指的就是字符链接文件(注意不是字符设备)，使用"l"表示其类型。

硬链接不能跨文件系统创建，否则inode号可能会冲突。于是实现了软链接以便跨文件系统建立链接。既然是跨文件系统，那么软链接必须得有自己的inode号。

软链接在功能上等价与Windows系统中的快捷方式，它指向原文件，原文件损坏或消失，软链接文件就损坏。可以认为软链接inode记录中的指针内容是目标路径的字符串。

> 创建方式： ln –s source_file softlink_name ，记住是source_file<--link_name的指向关系(反箭头)，以前我老搞错位置。
> 
> 查看软链接的值： readlink softlink_name

在设置软链接的时候，source_file虽然不要求是绝对路径，但建议给绝对路径。是否还记得软链接文件的大小?它是根据软链接所指向路径的字符数计算的，例如某个符号链接的指向方式为"rmt --> ../sbin/rmt"，它的文件大小为11字节，也就是说只要建立了软链接后，软链接的指向路径是不会改变的，仍然是"../sbin/rmt"。如果此时移动软链接文件本身，它的指向是不会改变的，仍然是11个字符的"../sbin/rmt"，但此时该软链接父目录下可能根本就不存在/sbin/rmt，也就是说此时该软链接是一个被破坏的软链接。

---
## inode的大小和划分

inode大小为128字节的倍数，最小为128字节。它有默认值大小，它的默认值由 <u>/etc/mke2fs.conf</u> 文件中指定。不同的文件系统默认值可能不同。

Ext预留了一些inode做特殊特性使用，如下：某些可能并非总是准确，具体的inode号对应什么文件可以使用"find / -inum NUM"查看。

-   Ext4的特殊inode
-   Inode号 用途
-   0 不存在0号inode
-   1 虚拟文件系统，如/proc和/sys
-   2 根目录
-   3 ACL索引
-   4 ACL数据
-   5 Boot loader
-   6 未删除的目录
-   7 预留的块组描述符inode
-   8 日志inode
-   11 第一个非预留的inode，通常是lost+found目录

所以在ext4文件系统的dumpe2fs信息中，能观察到fisrt inode号可能为11也可能为12。

并且注意到"/"的inode号为2，这个特性在文件访问时会用上。

需要注意的是，每个文件系统都会分配自己的inode号，不同文件系统之间是可能会出现使用相同inode号文件的。

---
## ext2/3的inode直接、间接寻址（Ext2/Ext3）

inode结构中使用一个长度15的char数组来存放inode指向的真正的数据块的内容
试想一下，如果数组中每一个元素都存的是一个数据块的序号，那么一个inode在块大小为4k的文件系统中最多只能存储 15 \* 4096 = 61440个字节的内容
这显然是不够的。因此，ext文件系统同时使用直接和间接寻址来处理这个问题。
**直接寻址** 指的是，对于数组的前12个内容，使用直接存储对应的块号。
从数组的第13个元素开始，使用**间接寻址**的方法：
数组第13位，i_block[12] 是*一级间接寻址指针*，它指向一个仍然存储了指针的block
第14个指针，i_block[13] 是*二级间接寻址指针*，它指向一个仍然存储了指针的block，但是这个block中的指针还继续指向其他存储指针的block
第15个指针，i_block[14] 是*三级间接寻址指针*，它指向一个任然存储了指针的block，这个指针block下还有两次指针指向。

![[Ext间接寻址.svg]]


---