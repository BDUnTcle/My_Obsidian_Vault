#Linux/linux命令笔记 #Linux/内核（Linux_Kernel） 
在[Linux系统](https://www.lxlinux.net/zhuanti-full "Linux系统")中[top命令](https://so.csdn.net/so/search?q=top%E5%91%BD%E4%BB%A4&spm=1001.2101.3001.7020)是常用的分析性能的工具，能够实时监控系统中各个进程资源占用的情况，这和windows中任务管理器有点类似。
## top参数详解

![](https://img-blog.csdnimg.cn/img_convert/aa2ba9b313e64e8c39921c8896c9740e.png)

  

**第一行，任务队列信息，同 uptime 命令的执行结果**

  
> 系统时间：07:27:05

> 运行时间：up 1:57 min,

> 当前登录用户： 3 user

> 负载均衡([uptime](https://so.csdn.net/so/search?q=uptime&spm=1001.2101.3001.7020)) load average: 0.00, 0.00, 0.00

>   average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。

> load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了

  

**第二行，Tasks — 任务（进程）**

> 总进程:150 total, 运行:1 running, 休眠:149 sleeping, 停止: 0 stopped, 僵尸进程: 0 zombie


**第三行，cpu状态信息**

> 0.0%us【user space】— 用户空间占用CPU的百分比。

> 0.3%sy【sysctl】— 内核空间占用CPU的百分比。

> 0.0%ni【】— 改变过优先级的进程占用CPU的百分比

> 99.7%id【idolt】— 空闲CPU百分比

> 0.0%wa【wait】— IO等待占用CPU的百分比

> 0.0%hi【Hardware IRQ】— 硬中断占用CPU的百分比

> 0.0%si【Software Interrupts】— 软中断占用CPU的百分比

**第四行,内存状态**

  

> 1003020k total,  234464k used,  777824k free,  24084k buffers【缓存的内存量】

  

**第五行，swap交换分区信息**

  

> 2031612k total,   536k used, 2031076k free,  505864k cached【缓冲的交换区总量】

  

> 备注：

>

> 可用内存=free + buffer + cached

>

> 对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。

>

> 第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，

>

> 第四行中空闲内存总量（free）是内核还未纳入其管控范围的数量。

>

> 纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。

  

**第六行，空行**

  

**第七行以下：各进程（任务）的状态监控**

  

> PID — 进程idUSER — 进程所有者PR — 进程优先级NI — nice值。负值表示高优先级，正值表示低优先级VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RESRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATASHR — 共享内存大小，单位kbS —进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程%CPU — 上次更新到现在的CPU时间占用百分比%MEM — 进程使用的物理内存百分比TIME+ — 进程使用的CPU时间总计，单位1/100秒COMMAND — 进程名称（命令名/命令行）

  

详解

  

> **VIRT：virtual memory usage 虚拟内存**1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等2、假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量

>

> **RES：resident memory usage 常驻内存**1、进程当前使用的内存大小，但不包括swap out2、包含其他进程的共享3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反4、关于库占用内存的情况，它只统计加载的库文件所占内存大小

>

> **SHR：shared memory 共享内存**1、除了自身进程的共享内存，也包括其他进程的共享内存2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小3、计算某个进程所占的物理内存大小公式：RES – SHR4、swap out后，它将会降下来

>

> **DATA**1、数据占用的内存。如果top没有显示，按f键可以显示出来。2、真正的该程序要求的数据空间，是真正在运行中要使用的。

>

> **top 运行中可以通过 top 的内部命令对进程的显示方式进行控制。内部命令如下：**s – 改变画面更新频率l – 关闭或开启第一部分第一行 top 信息的表示t – 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示m – 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示N – 以 PID 的大小的顺序排列表示进程列表P – 以 CPU 占用率大小的顺序排列进程列表M – 以内存占用率大小的顺序排列进程列表h – 显示帮助n – 设置在进程列表所显示进程的数量q – 退出 tops – 改变画面更新周期

  

## top使用方法

  

**使用格式：**

  

**top \[-\] \[d\] \[p\] \[q\] \[c\] \[C\] \[S\] \[s\] \[n\]**

  

**参数说明：**

  

**d：指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。**

  

**p:通过指定监控进程ID来仅仅监控某个进程的状态。**

  

**q:该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。**

  

**S：指定累计模式。**

  

**s：使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。**

  

**i：使top不显示任何闲置或者僵死进程。**

  

**c:显示整个命令行而不只是显示命令名。**

  

## 常用命令说明

  

**Ctrl+L：擦除并且重写屏幕**

  

**K：终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。**

  

**i：忽略闲置和僵死进程。这是一个开关式命令。**

  

**q：退出程序**

  

**r:重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。**

  

**S：切换到累计模式。**

  

**s：改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。**

  

**f或者F：从当前显示中添加或者删除项目。**

  

**o或者O：改变显示项目的顺序**

  

**l：切换显示平均负载和启动时间信息。**

  

**m:切换显示内存信息。**

  

**t:切换显示进程和CPU状态信息。**

  

**c:切换显示命令名称和完整命令行。**

  

**M:根据驻留内存大小进行排序。**

  

**P:根据CPU使用百分比大小进行排序。**

  

**T:根据时间/累计时间进行排序。**

  

**W:将当前设置写入~/.toprc文件中。**

  

## 查看多核CPU命令

  

mpstat -P ALL 和 sar -P ALL

  

说明：sar -P ALL > aaa.txt  重定向输出内容到文件 aaa.txt

  

**1 top 命令，然后按数字“1”可监控每个逻辑CPU的状况：**

  

![](https://img-blog.csdnimg.cn/img_convert/16577b8007a4004960a14bec09841bde.png)

  

**观察上图，服务器有8个逻辑CPU，实际上是1个物理CPU。**

  

**如果不按1，则在top视图里面显示的是所有cpu的平均值。**

  

**2 命令：mpstat -P ALL**

  

![](https://img-blog.csdnimg.cn/img_convert/af4da8d75321312df8b5f160b8d1526c.png)

  

**3 命令：sar -P ALL**

  

输出较多，可grep或者重定向至文件查看

  

![](https://img-blog.csdnimg.cn/img_convert/de459b72607d571350ddb5467a15d740.png)

  

## 进程字段排序

  

默认进入top时，各进程是按照CPU的占用量来排序的，在【top视图 01】中进程ID为14210的java进程排在第一（cpu占用100%），进程ID为14183的java进程排在第二（cpu占用12%）。可通过键盘指令来改变排序字段，比如想监控哪个进程占用MEM最多，我一般的使用方法如下：

  

\\1. 敲击键盘“b”（打开/关闭加亮效果），top的视图变化如下：

  

![](https://img-blog.csdnimg.cn/img_convert/24353c855621beacca086b3e23e4d39c.png)

  

我们发现进程id为12363的“top”进程被加亮了，top进程就是视图第二行显示的唯一的运行态（runing）的那个进程，可以通过敲击“y”键关闭或打开运行态进程的加亮效果。\\2. 敲击键盘“x”（打开/关闭排序列的加亮效果），top的视图变化如下：可以看到，top默认的排序列是“%CPU”。\\3. 通过”shift + >”或”shift + ”的效果图：

  

![](https://img-blog.csdnimg.cn/img_convert/f40f4935161d30250a19455ab33f8319.png)

  

视图现在已经按照%MEM来排序了。

  

## 改变进程显示字段

  

\\1. 敲击“f”键，top进入另一个视图，在这里可以编排基本视图中的显示字段：

  

![](https://img-blog.csdnimg.cn/img_convert/56bc3a139f10433cd9c32c8e9dfa6bd7.png)

  

这里列出了所有可在top基本视图中显示的进程字段，有”_”并且标注为大写字母的字段是可显示的，没有”_”并且是小写字母的字段是不显示的。如果要在基本视图中显示“CODE”和“DATA”两个字段，可以通过敲击“r”和“s”键：

  

\\2. “回车”返回基本视图，可以看到多了“CODE”和“DATA”两个字段：

  

![](https://img-blog.csdnimg.cn/img_convert/55c19d8fea7b70a14232c556fd2b0826.png)

