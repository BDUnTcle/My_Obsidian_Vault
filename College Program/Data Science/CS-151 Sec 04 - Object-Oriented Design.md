#SJSU #DataSince  #我的研究生 #CS

---
# Important Web
https://www.cs.sjsu.edu/faculty/pearce/modules/courses/Spring24/CS151/index.htm
---
# Syllabus
### Instructor
·        Jon Pearce
·        Office Location:  DH 239
·        Telephone:          (408) 924-5065
·        Email:                 [jon.pearce@sjsu.edu](mailto:jon.pearce@sjsu.edu)
### Office Hours
·        MW 1:30 – 3:00 in DH 239
·        By appointment on [Zoom](https://sjsu.zoom.us/j/8854363178)
### Lectures
·        Section 2: MW 10:30 – 11:45 in MH 223
·        Section 3: MW 12:00 – 1:15 in MH 223
·        Section 4: MW  3:00 – 4:15 in MH 223
### Prerequisites
·        Math 42, CS46B, and CS49J (or equivalent knowledge of Java) with a grade of C- or better in each.
## Course Description
Design of classes and interfaces. Object-oriented design methodologies and notations. Design patterns. Generics and reflection. Exception handling. Graphical user interface programming. Software engineering concepts and tools. Required team-based assignments.
### Section Description
Students will be introduced to the above concepts through a series of projects, some of which will be team-based.
### Course Learning Outcomes
Upon successful completion of this course, students will be able to:
1.      Interpret and produce UML class diagrams.
2.      Develop use-case models
3.      Select and apply key design patterns in the construction of a software application.
4.      Be able to follow a systematic OO design methodology
5.      Create a class hierarchy involving existing and new interfaces and classes, including inner classes.
6.      Design, implement, test, and debug large Java programs
7.      Use generic types, reflection, and lambda expressions
8.      Catch and throw exceptions
9.      Implement concurrent programs and thread-safe objects
10.  Use a GUI toolkit to create a graphical user interface involving frames, txt components, panels, menus, and simple geometric shapes.
11.  Document use cases for a team project.
12.  Plan and manage a team project
13.  Use version control and build systems.
### Required Texts/Readings
Lecture note and other materials will be posted at CS151 Course Website:
·        [https://www.cs.sjsu.edu/faculty/pearce/modules/courses/Spring24/CS151/index.htm](https://www.cs.sjsu.edu/faculty/pearce/modules/courses/Spring24/CS151/index.htm)
### Other equipment / material requirements
Students should bring laptops to class with the following software should be installed:
·        [IntelliJ IDEA](https://www.jetbrains.com/idea/) (the Edu version) with the Java 11 VM
·        [StarUML](https://staruml.io/)
### Course Requirements and Assignments
There will be several projects. Some will be team projects. In addition, there may be several in-class labs. Both labs and projects will require students to be proficient in writing and debugging Java programs.

_SJSU classes are designed such that in order to be successful, it is expected that students will spend a minimum of forty-five hours for each unit of credit (normally three hours per unit per week), including preparing for class, participating in course activities, completing assignments, and so on. More details about student workload can be found in University Policy S12-3 at_ [_http://www.sjsu.edu/senate/docs/S12-3.pdf._](http://www.sjsu.edu/senate/docs/S12-3.pdf)
### Grading Scheme
Course grades will be determined by computing a weighted average of all submitted work using the following weights:

|   |   |
|---|---|
|Assignments|60%|
|Midterm|15%|
|Final|25%|
|TOTAL|100%|

Weights of individual assignments appear on the [course assignments page](https://www.cs.sjsu.edu/faculty/pearce/modules/courses/Spring24/CS151/assignments/index.htm).
The averages appearing in Canvas are not weighted and do not correspond to your course grade.
Assuming a normal distribution of weighted averages, I will use the following scheme for computing letter grades:

|   |   |
|---|---|
|A|94% - 100%|
|A-|90% - 93%|
|B+|87% - 89%|
|B|84% - 86%|
|B-|80% - 83%|
|C+|77% - 79%|
|C|74% - 76%|
|C-|70% - 73%|
|D+|67% - 69%|
|D|64% -66%|
|D-|60% - 63%|
|F|0% - 59%|
### Classroom Protocol
Students should bring laptops to class and be prepared to work together on in-class labs.
### Academic Dishonesty Policy
Students are expected to do their own work on assignments and exams. Sharing or copying code (except code explicitly provided by the instructor or in the context of a team project) is cheating. Students will receive a 0 on any exam or assignment that contains plagiarized material. Cheating on the final exam may also result in failing the course. Students should not consult work from previous semesters as there will be subtle changes designed to prevent reusing old work.
### University Policies
_Per University Policy S16-9, university-wide policy information relevant to all courses, such as academic integrity, accommodations, etc. will be available on Office of Graduate and Undergraduate Programs’_ [_Syllabus Information web page_](http://www.sjsu.edu/gup/syllabusinfo/) _at http://www.sjsu.edu/gup/syllabusinfo/_

### Course Schedule
Below is a tentative schedule of topics and activities. The instructor reserves the right to make changes to the schedule with fair warning. Exact due dates of assignments are given on the Assignments Page (see below).

|   |   |   |   |
|---|---|---|---|
|**Week**|**Week**|**Topics**|**Projects**|
|1|1/24|Software Engineering||
|2|1/29 - 1/31|Requirements Modeling|Hospi Helper|
|3|2/5 - 2/7|Domain Modeling|
|4|2/12- 2/14|Design Patterns|Turtle Graphics|
|5|2/19 - 2/21|Graphical User Interfaces|
|6|2/26 – 2/28|Model-View Controller Architecture|
|7|3/4 - 3/6|Version control, Teamwork|Cellular Automata on mvc|
|8|3/11 - 3/13|Multithreading|
|9|3/18 - 3/20|Agent-Based Architecture|
|10|3/25 – 3/27|Midterm Review, Midterm||
|Spring Break|   |   |   |
|11|4/8 - 4/10|Agent-Based Architecture|Artificial Societies on SimStation|
|12|4/15 - 4/17|Distributed Architectures|
|13|4/22- 4/24|Distributed Architectures|Calculator on Echo|
|14|4/29 – 5/1|Container-Component Architecture|
|15|5/13|Container-Component Architecture|**Calculator on SmartBox**|
|12|5/9 - 5/12|Container-Component Architecture|

Assignment details can be found through the course [assignments page](https://www.cs.sjsu.edu/faculty/pearce/modules/courses/Spring24/CS151/assignments/index.htm).
### Final Exams

|   |   |   |   |
|---|---|---|---|
|Sec 2|Wednesday|15-May|9:45 - 12:00|
|Sec 3|Friday|17-May|9:45 - 12:00|
|Sec 4|Monday|20-May|12:15 - 2:30|

---

---
# Class Index
1. Class 1：-
2. Class 2 & 3：[[{CS151}-Class 2&3 Requirements Modeling]]
3. Class 4 & 5：[[{CS151}-Class 4&5 Domain Modeling]]
4. Class 6 & 7：[[{CS151}-Class 6&7 Design Patterns]]
5. Class 8 & 9：[[{CS151}-Class 8 & 9 Graphical User Interfaces]]
6. Class 10 & 11：[[{CS151}-Class 10 The Model-View-Controller-Architecture]]
7. Class 12 & 13：[[{CS151}-Class 11-Abstract Factory and Commands as Objects]]
8. Class 14 & 15：[[{CS151}Class 12-CALabs]]
9. Class 16 & 17：
10. Class 18 & 19：[[{CS151}-Class 14 Multithreading 1]] + [[{CS151}-Class 15 Multithreading 2]]
11. Class 20 & 21：
12. Class 22 & 23：[[{CS151}-Class 16 Readers and Writers problem]]
13. Class 24 & 25：[Midterm Review](https://www.cs.sjsu.edu/faculty/pearce/modules/courses/Spring24/CS151/midterm/MidtermReview.htm)
14. Class 26 & 27: [[{CS151}-Class 18]]
15. Class 28 & 29：[[{CS151}-Class 19]]
16. Class 20：[[{CS151}-Class 20]]
17. Class 21：[[{CS151}-Class 24]]

# Project Assignment
## Hospi-Helper
(https://www.cs.sjsu.edu/faculty/pearce/modules/labs/ooa2/funSpecs/HospitalityTracker.htm)
Hospi-Helper is an <u>online software system</u> that can be used by hotels and inns to manage reservations.
### For Use case model：
<u>Customers</u> and <u>hotel sales representatives</u> can use the system to *check room availability and room price*. They can also *make, modify, and cancel reservations*. When a reservation is made the <u>customer's bank</u> verifies the payment. When it is cancelled the customer's bank refunds the payment. <u>Housekeepers</u> can use the system to *update the ready status* of rooms (clean, ready to be occupied). <u>Front desk attendants</u> can use the system to *check guests into and out of rooms*.
### For domain model：
`Up to three rooms can be booked on a single reservation`. A **reservation** has <u>check-in and check-out dates</u>. It has a *status* (Cancelled, Confirmed, Paid, and in-Progress). It also has an **associated customer**. A customer is a guest who is at `least 21 years-old` with an associated credit card that will be used to pay for the reservation and incidentals.

A **credit card** must realize the following interface operations: *getAccountNumber*, *getExpirationDate*, *getSecurityCode*, and *charge* (which returns false if the charge fails for some reason). Currently, only Visa and MasterCard realize this interface.

A **guest** has an associated room and a unique key access code. A guest is also `associated with first and last name, address, phone number, and a date of birth`.

A **room** has a room number, a nightly rate, is either smoking or non-smoking, is or isn't occupied, and is or isn't ready (i.e., clean). There are <u>several types of rooms</u>: Queen, Double Queen, and King. A room is `associated with zero or more reservations that it is booked by`. It has `zero to three guests`.

---
# Class 1

## Overview of Software Engineering

in the *lifecycle models*:
requirements modal --> use case modal & domain model(different concepts and relationship between them)
design model

3 kinds of maintenance:（maintenance takes 60% of the whole model）
1. corrective（fixing bugs）
2. adaptive（adapt new platform）
3. perfective（add new features）：takes 60% of maintenance
---
# Class 2 - Requirements Modeling,Use Case Diagram
- Main Topic: Use Case Model
	- Identifying Actors(https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ooa/requirements/IdentifyingActors.htm)
	- Identifying Use Cases(https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ooa/requirements/IdentifyingUseCases.htm)

note:[[2024-01-29]]

---
# Class 3 - Use Case Model
- Main Topic: Use Case Model
	- Identifying Scenarios()
	- Relationships between Use Cases(https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ooa/requirements/relations.htm)
		- 3kinds of arrors
	- Use Case Model Anti-Patterns(https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ooa2/uc/antipatterns.htm)

**Customers** and **hotel sales representatives** can use the system to *check room availability* and *room price*. They can also *make, modify, and cancel reservations*. When a reservation is made the customer's **bank** *verifies the payment*. When it is cancelled the customer's bank *refunds the payment*. **Housekeepers** can use the system to *update the ready status of rooms* (clean, ready to be occupied). **Front desk attendants** can use the system to *check guests into and out of rooms*.

---
# Class 4 - Domain Model
## Domain Modeling
a bludeprint of code
[UML Class Diagrams](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/uml2/class/index.htm)
### Class Diagrams
(https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/uml2/class/index.htm)
1. *Class properties*
2. *Attributes*
3. *Operations*
## Association between Classes
1. generalization arrow
2. association

- +/-：public/private
- \# ：protected
- underlined function：static function
- abstract or not：if its italisized
- class
- interface
- **Data Types** and **Enumerations**
---
# Class 5 - Domain Model
## Domain Modeling
[UML Class Diagrams](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/uml2/class/index.htm)
### Class Diagrams
- What is “**constraint**” of a class and how to add it in starUML

About ：*consider creating interfaces for secondary actors*

if 
## Calss Diagram Anti-Patterns
(https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/uml/class/antipatterns/index.htm)

---


# Class 10 - Model-View-Controller

Layer 0 ：Business Logic：usually be volatile
Layer 1 ：Presentation Logic：is stable

Design Principle：
Business logic should be independent of Presentation logic

---
# Section Review
## Requirements and Domain Modeling
1. Requirements phase
	1. Use case diagram + domain model (class diagram)
2. Design phase
3. implementation phase
4. Testing phase
---
## Design Patterns 
A design pattern is a generic solution to a recurring design problem. Design patterns are collected together in pattern catalogs. Pattern catalogs are important resources for anyone who designs software. An architectural pattern is a design pattern for an entire system. It is often refined by smaller patterns. Some of the patterns discussed in class are shown in boldface below.
- [Abstract Factory](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/patterns/factories/index.htm)
- [[(Design Patterns)Actor-Role]]
- [Types as Objects](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/patterns/TypesAsObjects.htm)
- [[(Design Patterns)Adapter]]
- [[(Design Patterns)Composite]]
- [[(Design Patterns)Strategy]]
- [[(Design Patterns)Publisher-Subscriber]]
- [Commands as Objects Pattern](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/patterns/Commands/index.htm)
- [[(Design Pattern)Master-Slave]]
- [Proxy Design Pattern](https://www.cs.sjsu.edu/faculty/pearce/modules/patterns/distArch/proxy.htm)
- [Utility](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/patterns/Utility.htm)
- [The Model-View-Controller Architecture](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/mvc/index.htm)
---
## The Open-Closed Principle
>A system/class should be open to extension but closed to modification.

Examples:
- Extending a class
- Customizing a framework 
- Implementing an interface (e.g. strategy pattern)
---
## Java GUI Programming
Java GUIs are platform independent! The Java VM creates the GUI. It doesn't matter if the VM is running on Windows or MacOS. Still, the VM must use the GUI components of the underlying OS. It hides this dependency from the Java programmer by using the **Abstract Factory Pattern**. (Abstract factories are sometimes called toolkits, hence the name Abstract Windows Toolkit or awt.) Adapting native UI components to Java UI components relies of the **Adapter Pattern**.

Java's awt and swing packages provide us with a library of components (JComponent). There are two types of components: panels (JPanel) and controls. (JButton, JTextField, JLabel, etc.) A panel is a component container. It can contains controls and panels. This is an example of the **Composite Pattern**.

Layout of controls (buttons, text fields, labels, etc.) in a panel is done by nesting panels using different layout managers. This is an example of the **Strategy Pattern**.

When a button is clicked, it broadcasts an action event to all registered action listeners. More specifically, it calls their actionPerformed methods. This method executes commands associated with the button. This is an example of the **Publisher-Subscriber Pattern**.
Every Swing component has a paintComponent method. The paintComponent method for a panel simply calls the paintComponent methods of its members:
```java
public void paintComponent(Graphics gc) {  
   Color oldColor = gc.getColor();  
   Graphics2D gc2d = (Graphics2D)gc; // gc2d uses doubles instead of ints for coordinates   
   for(Component x: myComponents) x.paintComponent(gc2d)  
gc.setColor(oldColor);  
}
```
The parameter, gc, is like a virtual artists studio. It has a canvas and plenty of methods for drawing multi-colored points, lines, and shapes. The canvas has a coordinate system with the positive x-axis running across its top and the positive y-axis running down its left edge. We call this coordinate system user space.

A paintComponent is automatically called by the OS when a desktop window is resized or uncovered. You can ask the OS to redraw your panel by calling the repaint method. The OS maps the canvas to a region of the desktop (device space).

Create custom graphics by overriding paintComponent. For example, in the Stoplight Simulator the view panel overrode paintComponent so that it drew a stoplight. Each time the stoplight changed, the repaint method was called by the view panel.

- [Building Graphical User Interfaces](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/guis/index.htm)
- [Swing and AWT in JAVA](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/guis/swing.htm)

---
## The Model-View-Controller Architecture: mvc
- [The MVC Framework](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/mvc/mvc.htm)
- [Events](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/events/index.htm)
- [Serialization and Deserialization](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/guis/serialization/index.htm)
The **Model-View-Controller Pattern/Architecture** embodies an important design principle: business logic and data should be independent of presentation logic (user interfaces). Business logic (i.e. application-specific data logic) should be implemented in a serializable class generically called the model. There should be no references in the model to any user interface component. That way the model can support multiple user interfaces and changes to existing user interfaces won't propagate to the model.

The user interface should consist of views and a controller. Views present information about the model to the user. Examples include graphs, text, and animations. The controller executes user commands. Commands are often issued by clicking buttons, selecting menu items, etc. (Don't confuse control and controller.)

In a typical scenario the user clicks a button, the controller responds by updating the model, and the views redraw themselves. But how does the model tell the views to redraw themselves without referencing them? We used the **Publisher-Subscriber Pattern** to solve this problem. The model is the publisher and the views are the subscribers.

The mvc framework implements the Model-View-Controller a Architecture. The AppPanel is the controller since that's where the actionPerformed method is. The ViewPanel is the view, and Model is the model. Mvc also employs the **Abstract Factory Pattern** and the **Commands as Objects Pattern**.

The customizer creates subclasses of the mvc Model, AppPanel, Command, and ViewPanel classes as well as an implementation of the AppFactory interface. Minefield was a customization of the mvc framework.

---
## Java Multi-threading and Synchronization
- [Multithreading](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/threads/index.htm)
A thread is like a tiny JVM with its own call stack (but shares a heap). A thread has a start method that calls the run method of a runner if it has one. If not, it calls its own run method. To create a thread create an extension to Thread and override the run method or create a thread containing a runner (i.e. an instance of any class that implements the Runnable interface).

The run method of a cooperative thread should sleep occasionally to give other threads a chance to run.

If threads share an object such as a joint bank account, then that object should be made thread-safe by declaring its methods to be synchronized. (What does this do? How does it work? What happens if we don't do it?)

A thread executing a method of some shared object can suspend itself by calling the wait method of the object. This allows the thread to wait until needed changes to the object are made by another thread. After the changes are made the thread that made the changes calls the object's notify method. This is sort of an example of the **Publisher-Subscriber Pattern.** We saw an example in class with the joint bank account demo.

---
## Multi-Agent Architectures: Sim-Station
- [Agent-Based Systems](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/agents/index.htm)
- [SimStation](https://www.cs.sjsu.edu/faculty/pearce/modules/projects/ood/simStation/index.htm)
An agent is a semi-autonomous goal-driven object. More specifically, it's a thread with a run method like this:
```java
class Agent extends Thread {  
   State myGoal; // win, eat, mate, world peace, etc.  
   World world;  
   public void run() {|  
     while(world.state != myGoal) {  
        updateWorld(); // change the state of the world  
        sleep(1000); // be cooperative  
     }  
   }  
}
```
An **agent-based system or multi-agent architecture** consists of a manager and multiple agents. The manager creates a list of agents and calls their start methods. The manager can also pause, resume, and halt its agents (i.e., lifecycle management). The manager can also provide services to its agents such as helping agents to discover and communicate with other agents. The manager can also provide shared resources to its agents.  This is an example of the **Master-Slave Pattern**. For example, the manager might provide a virtual world that the agents can move around in and interact with.

Multi-agent systems such as NetLogo are used to simulate populations of humans and other animals moving about a virtual world and interacting with each other. Examples of interactions include fighting, mating, and game playing. There is no centralized-control in an agent-based system, and each agent only knows what's happening in its immediate neighborhood. Nevertheless, the population as a whole can exhibit complex patterns. This is called **emergent** **behavior**. Bird flocks, ant colonies, stock markets, and brains are examples.

Simstation is an implementation of the Multi-Agent Architecture. It is a framework for creating multi-agent simulations. It is also a customization of the mvc framework. The Simulation class is the model and the manager. Customizers create subclasses of Simulation and Agent. For example Tournament was a simulation consisting of a population of prisoner agents that played Prisoner's Dilemma with each other. Prisoners used different game-playing strategies. This was another example of the **Strategy Pattern**.

---
## Java Network Programming
Java provides a Socket class and a ServerSocket class. A socket consists of an input stream and an output stream. The input stream of one socket can be connected to the output stream of another and vice versa. This allows programs running on different computers to talk to each other (as long as the computers are connected to the Internet). Think of a socket as a virtual telephone.

In the telephone metaphor a server socket would be the equivalent of a virtual switchboard. Its "phone number" is the IP address of its host computer ("area code") and the port number on that computer. It has an accept method that blocks the caller until a connection request is received from a client. The accept method returns a socket connected to the client's socket. This socket is passed to an request handler agent that responds to the request.

---
## Client-Server Architecture:  Echo
- [Client-Server Architectures](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood3/distributed/ClientServer.htm)
- [Echo](https://www.cs.sjsu.edu/faculty/pearce/modules/projects/ood/simpleServer/echo/index.htm)
A distributed architecture is the big brother of a multi-agent architecture. Here agents are processes rather than threads and must communicate with each other using sockets. (A process is a running program with its own stack and heap while a thread is a running method within a program that shares the program's heap with other threads.)

Examples of distributed architectures include **pipeline, client-server, and peer-to-peer**. In a client-server architecture server agents respond to requests from client agents. In a peer-to-peer architecture peers send requests and responses to other peers. In pipelines agents are filters that read messages from a downstream filter, transform or test the message, then pass the result to an upstream filter.

In the Echo framework clients send connection requests to servers. The server creates a request handler agent connected to the client. (**Master-Slave Pattern**.) The client and request handler exchange messages (requests and responses) until the client sends the "quit" message. To customize Echo a programmer creates a subclass of RequestHandler that overrides the response method. The server uses reflection to create request handlers simply from the name of the request handler subclass.
A proxy server creates proxy request handlers:
```java
class ProxyHandler extends RequestHabndler {  
   Correspondent peer;  
   // etc.  
   String response(String request) {  
     String request2 = processRequest(request);  
     String response = peer.send(request2);  
     String response2 = processResponse(response);  
     returnb response2;  
   }  
}
```
The peer of a proxy handler might be another proxy handler or the request handler of the server. In this way proxies can form pipelines. This is an example of the **Proxy Design Pattern**. Examples of proxies include firewalls, cache proxies, and security proxies.

---
## Java Reflection
- [Reflection in Java](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/oop/types/reflection/reflection.htm)
The Java reflection package contains classes that represent fields, methods, and classes. Using reflection  programmers can write metaprograms—programs that create, process, or modify other programs. Examples of metaprograms include debuggers, compilers, IDEs, and CASE tools.
---
## Container-Component Architecture: Smart-Box
- [Container-Component Architectures and Component-Based Development](https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood4/cbd/index.htm)
In Component-Based Development (CBD) applications are created by adding off-the-shelf components to a container that connects them together. (Similar to the way circuit boards are built.) A component has a set of provided (implemented) interfaces and a set of required interfaces. If component A requires interface I and component B provides I, then the container would connect A to B. To do this, the container must be able to query A and B about their provided and required interfaces and then it must set the A's field of type I to a new instance of B. For example:
```java
class A extends Component {  
   I field; // A requires I  
   // etc.  
}

class B extends Component implements I { ... } // B provides I

A.field = new B(); // container must be able to do this using reflection
```
SmartBox is a container. To use it component developers create components (sub-classes of the Component class) then App builders can add them to smartBox.

---